<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detection Events</title>
    <link rel="stylesheet" href="/static/styles.css">
    <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
</head>
<body>
    <div class="temperature-display" id="temperatureDisplay">CPU: --°C</div>
    <div class="split-container">
        <div class="left-panel">
            <div class="metadata-list" id="metadataList"></div>
            <button class="refresh-button" onclick="updateMetadataList()">Refresh</button>
            <div class="vertical-splitter" id="verticalSplitter"></div>
            <div class="json-viewer" id="jsonViewer"></div>
        </div>
        <div class="splitter" id="splitter"></div>
        <div class="image-viewer">
            <div class="date-navigation">
                <button class="arrow-button" onclick="changeDate(1)">←</button>
                <div class="current-date" id="currentDate"></div>
                <button class="arrow-button" onclick="changeDate(-1)">→</button>
            </div>
            <div class="image-container">
                <video id="videoPlayer" class="video-js vjs-default-skin" controls preload="auto" width="640" height="360">
                    <p class="vjs-no-js">
                      To view this video please enable JavaScript, and consider upgrading to a web browser that
                      <a href="https://videojs.com/html5-video-support/" target="_blank">supports HTML5 video</a>
                    </p>
                </video>
                <div class="time-indicator" id="timeIndicator"></div>
            </div>
            <div class="button-container">
                <button class="review-button" id="reviewButton" onclick="toggleReviewState()">Reviewed</button>
                <div class="center-buttons">
                    <button class="pigeon-button yes" onclick="setPigeonLabel('pigeon')">PIGEON</button>
                    <button class="pigeon-button no" onclick="setPigeonLabel(null)">NOT PIGEON</button>
                    <button class="tag-button" onclick="toggleTagged()">Tag</button>
                </div>
                <button class="delete-button" onclick="deleteCurrentEntry()">Delete</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
    <script src="/static/App.js"></script>
    <script>
        // Add current date handling
        let currentDirectory = '';
        let availableDates = [];

        function getCurrentDateDir() {
            const now = new Date();
            return now.getFullYear().toString() +
                   (now.getMonth() + 1).toString().padStart(2, '0') +
                   now.getDate().toString().padStart(2, '0');
        }

        function formatDisplayDate(dateStr) {
            return `${dateStr.slice(0,4)}-${dateStr.slice(4,6)}-${dateStr.slice(6,8)}`;
        }

        function updateDateDisplay() {
            const dateElement = document.getElementById('currentDate');
            dateElement.textContent = formatDisplayDate(currentDirectory);
        }

        // New helper to refresh available dates from the server
        async function refreshAvailableDates() {
            try {
                const response = await fetch('/api/dates');
                availableDates = await response.json();
            } catch (error) {
                console.error('Error refreshing dates:', error);
            }
        }

        // Modified changeDate function to check folder existence before updating
        async function changeDate(offset) {
            await refreshAvailableDates(); // Refresh the date list

            const currentIndex = availableDates.indexOf(currentDirectory);
            const newIndex = currentIndex + offset;

            // Check if the new index is valid after refresh
            if (newIndex < 0 || newIndex >= availableDates.length) {
                console.warn('Date folder not found for the selected date.');
                return;
            }
            currentDirectory = availableDates[newIndex];
            updateDateDisplay();
            clearSelection();
            updateMetadataList();
            setupAutoRefresh();
        }

        function setupAutoRefresh() {
            const today = getCurrentDateDir();
            if (currentDirectory === today) {
                if (!window.autoRefreshInterval) {
                    window.autoRefreshInterval = setInterval(() => {
                        updateMetadataList();
                    }, 30000);
                }
            } else {
                if (window.autoRefreshInterval) {
                    clearInterval(window.autoRefreshInterval);
                    window.autoRefreshInterval = null;
                }
            }
        }

        let isResizing = false;
        let lastDownX = 0;
        let currentWidth = 300;

        // Splitter functionality
        const splitter = document.getElementById('splitter');
        const metadataList = document.getElementById('metadataList');
        
        splitter.addEventListener('mousedown', (e) => {
            isResizing = true;
            lastDownX = e.clientX;
            splitter.classList.add('dragging');
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const container = document.querySelector('.split-container');
            const leftPanel = document.querySelector('.left-panel');
            const listPanel = document.getElementById('metadataList');
            const jsonViewer = document.getElementById('jsonViewer');
            
            const delta = e.clientX - lastDownX;
            currentWidth = Math.max(200, Math.min(container.offsetWidth * 0.8, currentWidth + delta));
            
            // Update both left panel and its children
            leftPanel.style.width = `${currentWidth}px`;
            listPanel.style.width = `${currentWidth}px`;
            jsonViewer.style.width = `${currentWidth}px`;
            
            lastDownX = e.clientX;
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            splitter.classList.remove('dragging');
        });

        // Vertical splitter functionality
        let isVerticalResizing = false;
        let lastDownY = 0;
        let splitRatio = 0.6; // 60% for list, 40% for JSON

        const verticalSplitter = document.getElementById('verticalSplitter');
        const listPanel = document.getElementById('metadataList');
        const jsonPanel = document.getElementById('jsonViewer');
        
        verticalSplitter.addEventListener('mousedown', (e) => {
            isVerticalResizing = true;
            lastDownY = e.clientY;
            verticalSplitter.classList.add('dragging');
            e.preventDefault(); // Prevent text selection while dragging
        });

        document.addEventListener('mousemove', (e) => {
            if (!isVerticalResizing) return;
            
            const container = listPanel.parentElement;
            const containerHeight = container.offsetHeight;
            const mouseY = e.clientY;
            const containerRect = container.getBoundingClientRect();
            const relativeY = mouseY - containerRect.top;
            
            splitRatio = Math.max(0.1, Math.min(0.9, relativeY / containerHeight));
            
            // Update heights
            listPanel.style.flex = splitRatio;
            jsonPanel.style.flex = 1 - splitRatio;
        });

        document.addEventListener('mouseup', () => {
            if (isVerticalResizing) {
                isVerticalResizing = false;
                verticalSplitter.classList.remove('dragging');
            }
        });

        // Set initial panel sizes
        listPanel.style.flex = splitRatio;
        jsonPanel.style.flex = 1 - splitRatio;

        // Rest of the existing JavaScript for image cycling
        let currentImages = [];
        let currentIndex = 0;
        let imageInterval = null;
        let selectedItem = null;
        let currentJson = null;  // Store current JSON data

        function updateMetadataList() {
            console.log('Fetching metadata list for date:', currentDirectory);
            const list = document.getElementById('metadataList');
            list.innerHTML = '';

            fetch(`/api/metadata?date=${currentDirectory}`)
                .then(response => response.json())
                .then(files => {
                    const list = document.getElementById('metadataList');
                    const currentSelection = selectedItem;
                    list.innerHTML = '';
                    
                    // Add click handler to the list container for deselection
                    list.onclick = function(e) {
                        if (e.target === list) {
                            clearSelection();
                        }
                    };
                    
                    // Create an array of promises for fetching JSON data
                    const promises = files.map(file => 
                        fetch(`/media/${file}`)
                            .then(response => response.json())
                            .then(json => ({file, json}))
                            .catch(error => ({file, json: null}))
                    );
                    
                    // Wait for all JSON data to be fetched
                    Promise.all(promises)
                        .then(results => {
                            results.forEach(({file, json}) => {
                                const item = document.createElement('div');
                                item.className = 'event-item';
                                
                                // Add appropriate class based on label
                                if (json && json.label === 'pigeon') {
                                    item.classList.add('pigeon');
                                } else if (json && json.reviewed === true) {
                                    item.classList.add('reviewed');
                                }
                                
                                if (file === currentSelection) {
                                    item.classList.add('selected');
                                }
                                
                                // Set filename text
                                item.textContent = file.replace('.json', '');
                                
                                // If tagged, append a Unicode star as a span element
                                if (json && json.tagged) {
                                    const starSpan = document.createElement('span');
                                    starSpan.className = 'star-icon';
                                    starSpan.textContent = '⭐';
                                    item.appendChild(starSpan);
                                }
                                
                                item.setAttribute('data-filename', file);
                                item.onclick = (e) => {
                                    e.stopPropagation();
                                    selectEvent(file, item);
                                };
                                list.appendChild(item);
                            });
                        });
                })
                .catch(error => {
                    console.error('Error fetching metadata:', error);
                    const list = document.getElementById('metadataList');
                    list.innerHTML = '<div class="event-item error">Error loading events</div>';
                });
        }

        // Updated clearSelection to stop, remove event listeners, clear source, and remove video content
        function clearSelection() {
            selectedItem = null;
            currentJson = null;
            document.querySelectorAll('.event-item').forEach(item => item.classList.remove('selected'));

            // Clear JSON viewer
            document.getElementById('jsonViewer').innerHTML = '';

            // Stop and clear video player contents
            const videoPlayer = videojs('videoPlayer');
            if (videoPlayer) {
                videoPlayer.pause();
                videoPlayer.reset();
            }
            
            document.getElementById('timeIndicator').textContent = '';

            const button = document.getElementById('reviewButton');
            button.innerHTML = 'Reviewed';
        }

        function formatJsonValue(value, indent) {
            if (typeof value === 'string') return `<span class="string">"${value}"</span>`;
            if (typeof value === 'number') return `<span class="number">${value}</span>`;
            if (typeof value === 'boolean') return `<span class="boolean">${value}</span>`;
            if (value === null) return `<span class="null">null</span>`;
            if (Array.isArray(value)) {
                const items = value.map(item => formatJsonValue(item, indent + 2)).join(',\n' + ' '.repeat(indent + 2));
                return `[\n${' '.repeat(indent + 2)}${items}\n${' '.repeat(indent)}]`;
            }
            if (typeof value === 'object') {
                return formatJsonObject(value, indent + 2);
            }
            return String(value);
        }

        function formatJsonObject(obj, indent = 0) {
            const entries = Object.entries(obj);
            const lines = entries.map(([key, value]) => {
                const formattedValue = formatJsonValue(value, indent);
                return `${' '.repeat(indent)}<span class="key">"${key}"</span>: ${formattedValue}`;
            });
            return lines.join(',\n');
        }

        function displayJson(json) {
            currentJson = json;  // Save reference to current JSON
            const viewer = document.getElementById('jsonViewer');
            viewer.innerHTML = `{\n${formatJsonObject(json, 2)}\n}`;
        }

        function selectEvent(filename, element) {
            selectedItem = filename;
            document.querySelectorAll('.event-item').forEach(item => 
                item.classList.remove('selected'));
            element.classList.add('selected');
            
            // Load and display JSON content
            fetch(`/media/${filename}`)
                .then(response => response.json())
                .then(json => {
                    displayJson(json);
                    // Update review button state
                    const reviewButton = document.getElementById('reviewButton');
                    reviewButton.innerHTML = `Reviewed${json.reviewed ? ' ✓' : ''}`;
                    // Update tag button state
                    const tagButton = document.querySelector('.tag-button');
                    tagButton.innerHTML = `Tag${json.tagged ? ' ✓' : ''}`;
                });
            
            const baseFilename = filename.replace('.json', '');
            const videoFilename = `/media/${baseFilename}.mp4`;
            
            const videoPlayer = videojs('videoPlayer');
            videoPlayer.pause();
            videoPlayer.src({
                src: videoFilename,
                type: 'video/mp4'
            });
            videoPlayer.load();

            // Check if video can play
            videoPlayer.on('canplay', function() {
                videoPlayer.play();
            });

            // Handle error if video cannot be loaded
            videoPlayer.on('error', function(e) {
                console.error('Video error:', videoPlayer.error());
            });
        }

        function showCurrentImage() {
            if (currentImages.length > 0) {
                const img = document.getElementById('currentImage');
                img.src = `/media/${currentImages[currentIndex]}`;
                document.getElementById('timeIndicator').textContent = 
                    `Image ${currentIndex + 1} of ${currentImages.length}`;
            }
        }

        function updateSingleListItem(filename, json) {
            const item = document.querySelector(`[data-filename="${filename}"]`);
            if (!item) return;

            // Remove any existing special classes
            item.classList.remove('reviewed', 'pigeon');
            
            // Add appropriate class based on new label
            if (json.label === 'pigeon') {
                item.classList.add('pigeon');
            } else if (json.reviewed === true) {
                item.classList.add('reviewed');
            }
        }

        function deleteCurrentEntry() {
            if (!selectedItem) return;

            const baseFilename = selectedItem.replace('.json', '');
            fetch(`/api/delete/${baseFilename}?date=${currentDirectory}`, {
                method: 'DELETE'
            })
            .then(response => {
                if (!response.ok) throw new Error('Failed to delete');
                console.log('Files deleted successfully');
                updateMetadataList();
                clearSelection();
            })
            .catch(error => console.error('Error deleting files:', error));
        }

        function toggleReviewState() {
            if (!selectedItem || !currentJson) return;

            // Toggle the reviewed state
            currentJson.reviewed = !currentJson.reviewed;

            // If marking as reviewed and no label exists, set to null
            if (currentJson.reviewed && !currentJson.label) {
                currentJson.label = null;
            }

            // Update the button text
            const button = document.getElementById('reviewButton');
            button.innerHTML = `Reviewed${currentJson.reviewed ? ' ✓' : ''}`;

            // Update display
            displayJson(currentJson);
            updateSingleListItem(selectedItem, currentJson);

            // Send updated JSON to server
            fetch(`/api/update/${selectedItem}?date=${currentDirectory}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(currentJson)
            })
            .then(response => {
                if (!response.ok) throw new Error('Failed to update');
                console.log('Review state updated successfully');
            })
            .catch(error => console.error('Error updating review state:', error));
        }

        function setPigeonLabel(label) {
            if (!selectedItem || !currentJson) return;

            // Set the label and mark as reviewed
            currentJson.label = label;
            currentJson.reviewed = true;

            // Update displays
            displayJson(currentJson);
            updateSingleListItem(selectedItem, currentJson);
            
            // Update review button
            const reviewButton = document.getElementById('reviewButton');
            reviewButton.innerHTML = 'Reviewed ✓';

            // Send updated JSON to server
            fetch(`/api/update/${selectedItem}?date=${currentDirectory}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(currentJson)
            })
            .then(response => {
                if (!response.ok) throw new Error('Failed to update');
                console.log('Pigeon label updated successfully');
            })
            .catch(error => console.error('Error updating pigeon label:', error));
        }

        function toggleTagged() {
            if (!selectedItem || !currentJson) return;

            // Toggle the tagged state and set reviewed to true
            currentJson.tagged = !currentJson.tagged;
            currentJson.reviewed = true;

            // Update display
            displayJson(currentJson);
            updateSingleListItem(selectedItem, currentJson);
            
            // Update review and tag button texts
            const reviewButton = document.getElementById('reviewButton');
            reviewButton.innerHTML = 'Reviewed ✓';
            const tagButton = document.querySelector('.tag-button');
            tagButton.innerHTML = `Tag${currentJson.tagged ? ' ✓' : ''}`;
            
            // Update star icon in the selected list item
            const listItem = document.querySelector(`[data-filename="${selectedItem}"]`);
            if (listItem) {
                const existingStar = listItem.querySelector('.star-icon');
                if (currentJson.tagged) {
                    if (!existingStar) {
                        const starSpan = document.createElement('span');
                        starSpan.className = 'star-icon';
                        starSpan.textContent = '⭐';
                        listItem.appendChild(starSpan);
                    }
                } else {
                    if (existingStar) {
                        existingStar.remove();
                    }
                }
            }
            
            // Send updated JSON to server
            fetch(`/api/update/${selectedItem}?date=${currentDirectory}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(currentJson)
            })
            .then(response => {
                if (!response.ok) throw new Error('Failed to update');
                console.log('Tag state updated successfully');
            })
            .catch(error => console.error('Error updating tag state:', error));
        }

        function updateTemperature() {
            fetch('/api/cpu_temperature')
                .then(response => response.json())
                .then(data => {
                    if (data.temperature) {
                        document.getElementById('temperatureDisplay').textContent = 
                            `CPU: ${data.temperature}°C`;
                    }
                })
                .catch(error => console.error('Error fetching temperature:', error));
        }

        // Update temperature every 60 seconds
        setInterval(updateTemperature, 60000);  // Changed from 5000 to 60000 ms
        // Initial temperature update
        updateTemperature();

        // Initial setup
        async function initialize() {
            metadataList.style.width = currentWidth + 'px';
            selectedItem = null;
            currentJson = null;
            
            // Get available dates from server
            const response = await fetch('/api/dates');
            availableDates = await response.json();
            
            // Set current directory to most recent date
            currentDirectory = availableDates[0] || getCurrentDateDir();
            updateDateDisplay();
            updateMetadataList();
            setupAutoRefresh();
        }

        initialize();
    </script>
</body>
</html>
